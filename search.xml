<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ES5属性描述符和访问描述符]]></title>
    <url>%2F2019%2F04%2F29%2FES5%E5%B1%9E%E6%80%A7%E6%8F%8F%E8%BF%B0%E7%AC%A6%E5%92%8C%E8%AE%BF%E9%97%AE%E6%8F%8F%E8%BF%B0%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[属性描述符获取一个对象的属性描述符的方法是Object.getOwnPropertyDescriptor()，这个方法接收两个参数，第一个是要获取属性描述符的对象，第二个是这个对象的一个属性，用法如下： 1234567891011let obj = &#123; a: 2&#125;;Object.getOwnPropertyDescriptor(obj,&apos;a&apos;);&#123; configurable: true, enumerable: true, value: 2, writable: true&#125; 有获取的方法，就一定有修改的方法，这个方法是Object.defineProperty()，这个方法接收三个参数，第一个是要修改属性描述符的对象，第二个是这个对象的一个属性，第三个是属性描述符对象，用法如下： 12345678910let obj = &#123;&#125;;Object.defineProperty(obj,&apos;b&apos;,&#123; configurable: true, enumerable: true, value: &apos;llt&apos;, writable: false&#125;)obj.b //&apos;llt&apos;obj.b = &apos;emm&apos;obj.b //&apos;llt&apos; 这里修改了writable可写性，所以无法在修改b的属性值，在严格模式中这样做还会报错。 configurable:可配置性如果我们用Object.defineProperty()这个方法将configurable的值修改为false，那么这个操作将是不可逆的，也就是说，之后再用Object.defineProperty()方法去修改configurable是不好用的。但是有一个例外，就是在这种情况下writable可以由true变为false，但是无法从false变为true: 123456789101112131415161718let obj = &#123;&#125;;Object.defineProperty(obj, &apos;b&apos;, &#123; configurable: false, enumerable: true, value: &apos;llt&apos;, writable: true&#125;)obj.b = &apos;emm&apos;;console.log(obj.b) //&apos;emm&apos;Object.defineProperty(obj, &apos;b&apos;, &#123; configurable: false, enumerable: true, value: &apos;llt&apos;, writable: false&#125;)obj.b = &apos;emmm&apos;console.log(obj.b) //&apos;llt&apos; 不变性这里要说到一个浅不变性，就是因为这个，曾经我和我的同事争辩得面红耳赤，后悔没早看这本书，在这本书里找到了答案。书中是这样说的：所有的方法创建的都是浅不变性，它们只能影响目标对象和它的直接属性，如果目标对象引用了其他对象，其他对象的内容不受影响，仍然是可变的。 123456let obj = &#123; a: 2, b: [1,2,3]&#125;obj.b.push(4)console.log(obj.b) //[1,2,3,4] 禁止扩展学编程，英语真的很重要，因为很多方法的名字就是这么来的，禁止扩展拆开来看，禁止英文是prevent，扩展英文extensions，所以禁止扩展的方法就是Object.preventExtensions()，禁止扩展顾名思义就是禁止对象添加新属性。 123456let obj = &#123; a: 2&#125;;Object.preventExtensions(obj);obj.b = &apos;llt&apos;;console.log(obj.b) //undefined 密封Object.seal()，这个方法会在一个现有对象上调用Object.preventExtensions()方法，然后将所有现有属性标记为configurable:false。这个方法厉害了，不仅不能添加新属性，还不能重新配置属性或者删除任何现有属性，看configurable就知道了。 冻结Object.freeze()，这个方法更厉害，它先是调用Object.seal()，然后在这个方法的基础上，将writable设置为false。 访问描述符（数据描述符）getter和setter访问描述符会忽略value和writable，关心get和set。 1234567891011let myObject = &#123; get a() &#123; return this._a_ &#125;, set a(value) &#123; this._a_ = value * 2 &#125;&#125;myObject.a = 2;myObject.a // 4 其他与对象有关的点in 和 getOwnProperty检查一个对象的一个属性是因为不存在而返回的undefined还是属性中存储的是undefined，可以用两种方法：in操作符和hasOwnProperty。 用法如下： 12345678let myObject = &#123; a: undefined&#125;(&quot;a&quot; in myObject); //true(&quot;b&quot; in myObject); //falsemyObject.hanOwnProperty(&quot;a&quot;); //true 这两个方法的区别是：in不光会检查对象本身，还会检查其原型链，而getOwnProperty只会检查对象本身是否存在对应属性。 枚举检查属性名是否存在当前对象，不包括原型链，并且enumberable:true的属性； 获取对象属性的方法有两种：Object.keys()和Object.getOwnPropertyNames()，两者的区别是Object.keys()会返回一个包含所有可枚举属性的数组，Object.getOwnPropertyNames()会返回包含所有属性的数组，不管可不可枚举，相同点是都只会查找对象自身的属性。 遍历有一种遍历方法可以直接遍历出值，它就是for…of，要求是必须有内置的@@iterator，数组有这个内置的@@iterator，普通的对象是没有的，不过，我们可以利用前面的设置属性描述符的方法让普通的对象也可以用for…of。 for…of循环首先会向被访问对象请求一个迭代器对象，然后通过迭代器对象的next()方法来遍历所有返回值。 12345678let myArray = [1,2,3];// 使用Symbol.iterator获取对象的@@iterator属性let it = myArray[Symbol.iterator]();it.next() // &#123;value: 1, done: false&#125;it.next() // &#123;value: 2, done: false&#125;it.next() // &#123;value: 3, done: false&#125;it.next() // &#123;done: true&#125; 让for…of获取普通对象的值： 1234567891011121314151617181920212223let myObject = &#123; a: 2, b: 3&#125;Object.defineProperty(myObject,Symbol.iterator,&#123; enumberable: false, writable: false, configurable: true, value: function () &#123; let o = this; let index = 0; let ks = Object.keys(o); return &#123; next: function() &#123; return &#123; value: o[ks[index++]], done: (index&gt;ks.length) &#125; &#125; &#125; &#125;&#125;)]]></content>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[this]]></title>
    <url>%2F2019%2F04%2F28%2Fthis%2F</url>
    <content type="text"><![CDATA[关于javascript中的this，已经有很多篇文章对它进行过阐述，他们写的都很好，本篇仅作为《你不知道的javascript》关于this的读后感总结。 this和动态作用域很像，相信熟悉动态作用域的开发者应该更容易理解this，但是javascript是基于词法作用域，所以这对我们理解this造成了很多的误解。 this的绑定和函数声明的位置没有任何关系，this是在调用时被绑定的，在javascript中，有四种调用函数的方式： 1、作为普通函数调用；2、作为对象方法调用；3、构造函数调用；4、call()和apply(); 作为普通函数调用123456function foo() &#123; var a = 2; console.log(this.a)&#125;foo() //undefined 此时，foo的调用位置在全局作用域，它的this指向window对象，有一点需要注意：在严格模式下运行foo，this指向undefined，但是在严格模式下调用foo，this还是会指向window。 123456function foo() &#123; &quot;use strict&quot; console.log(this.a)&#125;var a = 3;foo() //TypeError:this is undefined 12345678function foo() &#123; console.log(this.a)&#125;var a = 3;(function()&#123; &quot;use strict&quot; foo()&#125;)() //3 作为对象方法调用1234567891011function foo() &#123; var a = 2; console.log(this.a)&#125;let obj = &#123; a: 3, foo&#125;obj.foo() //3 此时，foo的调用位置存在一个obj的上下文对象，this指向这个上下文对象，下面看另一段代码： 12345678910111213function foo() &#123; function bar() &#123; console.log(this.a) &#125; return bar();&#125;let obj = &#123; a: 3, foo&#125;obj.foo() //undefined 在没有输出结果之前，很容易会理所当然的认为输出3，因为我们把内部函数的this看成是和外部函数的this一样，但其实，内部函数的上下文环境取决于调用环境，而不是外部函数的上下文环境。 陷阱1： 123456789101112function foo() &#123; console.log(this.a)&#125;;let obj2 = &#123; a: 4, foo: foo&#125;;let obj1 = &#123; a: 3, obj2: obj2&#125;;obj1.obj2.foo() //4 根据打印结果，也能知道this是指向obj2，对象属性引用链中只有最后一层在调用位置中起作用。 陷阱2： 12345678910function foo() &#123; console.log(this.a)&#125;let obj = &#123; a: 3, foo&#125;let bar = obj.foo;bar() //undefined 在这里，bar变量保存了对obj.foo的一个引用，但是实际上，它指向的是foo函数本身，所以，调用bar，等同于直接调用全局作用域中的foo，所以，this指向window。 陷阱3：回调函数 1234567891011function foo() &#123; console.log(this.a)&#125;;function bar(fn) &#123; fn()&#125;;let obj = &#123; a: 3, foo&#125;bar(obj.foo) //undefined 参数传递其实就是一种隐性赋值，所以和陷阱2道理是一样的，只是这个更具有迷惑性。 构造函数调用构造函数调用必须带有new，首先要知道使用new来调用函数时，都发生了哪些事情？ 1、创建一个新对象，var obj = {};2、设置新对象的proto属性指向构造函数的prototype对象，obj.proto = Foo.prototype;3、函数中的this被绑定到新对象，Foo.call(obj);4、如果函数没有返回其他对象，则返回这个新对象； 所以，构造函数的this会绑定到新创建的对象上。 call和apply不多说了。]]></content>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS作用域]]></title>
    <url>%2F2019%2F04%2F26%2FJS%E4%BD%9C%E7%94%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[最近在读《你不知道的javascript》，作者很幽默，写的东西很容易让人理解，俗话说好记性不如烂笔头，很多知识当时理解，过一段时间就会忘记，记录在这里，既可以巩固学到的知识，又可以在日后忘记的时候回来看一眼。 理解作用域计算机最基本的功能是对数据进行存储和读取，而在javascript中，作用域相当于一套规则，用来保存和读取在写代码过程中定义的那些值，将它们保存在一定的范围内。如果查找的目的是对变量赋值，就会使用LHS查询，如果查找的目的是找到变量的值，则会使用RHS查询。 作用域嵌套作用域之间会有嵌套，代码如下： 123456function foo(a) &#123; var b = 2; function bar() &#123; console.log(a+b) &#125;&#125; 在全局作用域中只有一个foo，在foo作用域中，还有一个bar作用域，在bar作用域中并没有变量a和变量b，代码在执行时，会创建作用域链，引擎会从当前的作用域中查找变量，找不到，就会向上一层继续找，当找到全局作用域还没找到，查找过程便会停止。 词法作用域和动态作用域词法作用域和动态作用域的区别：词法作用域又称静态作用域，因为它是在写代码或定义时确定的，它关注函数在何处声明；动态作用域时在运行时确定的，它关注函数在何处调用； 到这里，我会思考如何证明js是基于词法作用域，代码如下： 123456789101112function foo () &#123; console.log(a)&#125;var a = 2;function bar () &#123; var a = 3; foo()&#125;bar() //2 如果想看动态作用域的效果，可以在自己电脑装一个虚拟机，然后装一个deepin系统，创建个文本文件，输入命令”mv test.txt test.bash”(我不知道怎么直接创建.bash文件，所以创建一个txt文件然后用命令行更改的)，然后输入”chmod u+x test.bash”(这个是加运行权限)，在命令行里输入”./test.bash”(运行文件)，你就会看到打印出来的3，代码如下： 123456789a=2function foo () &#123; echo $a;&#125;function bar () &#123; local a=3; foo;&#125;bar 声明提升在编译阶段，所有声明都会在代码被执行前首先被处理。除了函数作用域，ES6还增加了块作用域，用let和const声明的变量，可以隐性的劫持所在的块作用域，但是要注意，用let和const声明的变量不存在声明提升。 闭包结合小红书，个人的总结是：一个函数，保存了对另一个函数作用域的引用，导致垃圾回收机制无法清除，这时，就产生了闭包。 12345678910function foo() &#123; var a = 2; function baz() &#123; console.log(a) &#125; bar(baz)&#125;function bar(fn) &#123; fn();&#125; 这里，foo和bar都是在全局作用域中的函数，其中，foo函数作用域包含baz函数作用域，根据作用域查找规则，在foo中调用的bar函数实际上就是全局作用域中的bar，而这里将baz作为bar的实参传给了bar，因此，bar持有对参数baz的引用，这就产生了闭包。]]></content>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo搭建博客]]></title>
    <url>%2F2019%2F03%2F02%2Fhexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[1、搜索node官网安装node，安装成功打开命令行（window快捷键window+R），输入node -v和npm -v，出现版本号即为成功；2、安装git，安装成功右键桌面会有GIT BUSH Here和GIT GUI Here，同样，命令行输入git –version出现版本号即为成功；3、在github账号上创建一个repositories，项目必须要遵守格式：账户名.github.io，勾选Initialize this repository with a README，description可写可不写；4、安装hexo，命令行输入：npm install hexo -ghexo -v 检查是否安装成功5、接下来我在D盘创建了一个blog文件夹，cd到这个文件夹，执行hexo init，初始化该文件夹，成功后命令行会出现“Start blogging with Hexo”；6、接下来npm install，安装所需的组件；7、hexo g （hexo generate简写） 初次体验hexo；8、hexo s（hexo server简写）启动服务器，如果端口号被占用，输入“hexo server -p 端口号”改变端口号；出现下图即成功；博客搭建完成，但是如果想要好看的话，还需要下载主题并配置主题，个人比较喜欢next主题。]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
